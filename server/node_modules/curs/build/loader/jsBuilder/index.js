"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSBuilder = void 0;
var JSBuilder = /** @class */ (function () {
    function JSBuilder() {
        this._id = 1;
        this._total = 0;
    }
    JSBuilder.prototype.build = function (tagTree) {
        var _this = this;
        var code = "";
        tagTree.children.forEach(function (tag) {
            if (_this["_" + tag.tag]) {
                code += _this["_" + tag.tag](tag);
            }
        });
        code = "scene.loading.total = " + this._total + ";\n " + code;
        this._total = 0;
        this._id = 1;
        return code;
    };
    JSBuilder.prototype._getVarName = function () {
        return "var_" + this._id++;
    };
    JSBuilder.prototype._audio = function (tagTree) {
        this._total++;
        var type = "Audio";
        if (tagTree.parent) {
            tagTree.parent.tag === "render" ? "" : type = "PositionalAudio";
        }
        var code = "\n          const sound = new THREE." + type + "(scene.audioListener);\n          const audioLoader = new THREE.AudioLoader();\n          audioLoader.load('" + tagTree.attrs.url + "', (buffer) => {\n               scene.loading.count++;\n               scene.loading.progress = scene.loading.count/scene.loading.total * 100 + \"%\";\n               sound.setBuffer(buffer);\n               " + (tagTree.attrs.loop ? "sound.setLoop(true);" : "") + "\n               " + (tagTree.attrs.volume ? "sound.setVolume(" + tagTree.attrs.volume + ");" : "") + "\n               " + (tagTree.attrs.autoPlay ? "sound.play();" : "") + "\n               " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = sound;" : "") + "\n               scene.loading.count === scene.loading.total ? scene.ready() :\"\";\n           });\n          ";
        var funcName = this._getVarName();
        code = "function " + funcName + "(){" + code + "};\n " + funcName + "();\n";
        return code;
    };
    JSBuilder.prototype._model = function (tagTree) {
        this._total++;
        var loader = tagTree.attrs.type === "fbx" ? "FBXLoader" : "GLTFLoader";
        var code = "\n          const loader = new " + loader + "();\n          loader.load(\n               \"" + tagTree.attrs.url + "\",\n               (model)=>{\n                    scene.loading.count++;\n                    scene.loading.progress = scene.loading.count/scene.loading.total * 100 + \"%\";\n                    const animations = model.animations;\n                    " + (tagTree.attrs.type === "fbx" ? "" : "model = model.scene;\n model.animations = animations ;") + "\n                    " + (tagTree.attrs.shadow ? "model.traverse(child => {if (child.isMesh) {child.castShadow = true;child.receiveShadow = true;}});" : "") + "\n                    " + (tagTree.attrs.position ? "model.position.set(" + tagTree.attrs.position.x + "," + tagTree.attrs.position.y + "," + tagTree.attrs.position.z + ");" : "") + "\n                    " + (tagTree.attrs.rotation ? "model.rotation.set(" + tagTree.attrs.rotation.x + "," + tagTree.attrs.rotation.y + "," + tagTree.attrs.rotation.z + ");" : "") + "\n                    " + (tagTree.attrs.scale ? "model.scale.set(" + tagTree.attrs.scale.x + "," + tagTree.attrs.scale.y + "," + tagTree.attrs.scale.z + ");" : "") + "\n                    " + (tagTree.attrs.visible === false ? "model.visible = false;" : "") + "\n                    " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = model;" : "") + "\n                    scene.add(model);\n                    scene.loading.count === scene.loading.total ? scene.ready() :\"\";\n               },\n               undefined,\n               (err)=>{\n                    console.log(err);\n               }\n          )\n          ";
        var funcName = this._getVarName();
        code = "function " + funcName + "(){\n " + code + "};\n " + funcName + "();\n ";
        return code;
    };
    JSBuilder.prototype._light = function (tagTree) {
        var light = "const light = ";
        var shadow = "\n          light.castShadow = true;\n          light.shadow.mapSize.width = 1024;\n          light.shadow.mapSize.height = 1024;\n          light.shadow.camera.near = 0.1;\n          light.shadow.camera.far = 500;\n          ";
        if (tagTree.attrs.type === "AmbientLight") {
            light += "new THREE.AmbientLight( " + (tagTree.attrs.color ? tagTree.attrs.color : "0xffffff") + " );";
        }
        else if (tagTree.attrs.type === "PointLight") {
            light += "new THREE.PointLight( \n                    " + (tagTree.attrs.color ? "," + tagTree.attrs.color : "0xffffff") + "\n                    " + (tagTree.attrs.intensity ? "," + tagTree.attrs.intensity : "") + "\n                    " + (tagTree.attrs.distance ? "," + tagTree.attrs.distance : "") + "\n                    " + (tagTree.attrs.decay ? "," + tagTree.attrs.decay : "") + "\n                );";
            tagTree.attrs.shadow ? light += shadow : "";
        }
        else if (tagTree.attrs.type === "SpotLight") {
            light += "new THREE.SpotLight( \n                    " + (tagTree.attrs.color ? tagTree.attrs.color : "0xffffff") + "\n                    " + (tagTree.attrs.intensity ? "," + tagTree.attrs.intensity : ",1") + "\n                    " + (tagTree.attrs.distance ? "," + tagTree.attrs.distance : ",5") + "\n                    " + (tagTree.attrs.angle ? "," + tagTree.attrs.angle : "") + "\n                    " + (tagTree.attrs.penumbra ? "," + tagTree.attrs.penumbra : "") + "\n                    " + (tagTree.attrs.decay ? "," + tagTree.attrs.decay : "") + "\n                );";
            tagTree.attrs.shadow ? light += shadow : "";
        }
        else if (tagTree.attrs.type === "RectAreaLight") {
            light += "new THREE.RectAreaLight( \n                    " + (tagTree.attrs.color ? tagTree.attrs.color : "0xffffff") + "\n                    " + (tagTree.attrs.intensity ? "," + tagTree.attrs.intensity : "") + "\n                    " + (tagTree.attrs.width ? "," + tagTree.attrs.width : "") + "\n                    " + (tagTree.attrs.height ? "," + tagTree.attrs.height : "") + "\n                );";
        }
        else if (tagTree.attrs.type === "HemisphereLight") {
            light += "new THREE.HemisphereLight( \n                    " + (tagTree.attrs.sky ? tagTree.attrs.sky : "0xffffff") + "\n                    " + (tagTree.attrs.ground ? "," + tagTree.attrs.ground : "0x000000") + "\n                    " + (tagTree.attrs.intensity ? "," + tagTree.attrs.intensity : "") + "\n                );";
        }
        else {
            light += "new THREE.DirectionalLight( \n                    " + (tagTree.attrs.color ? tagTree.attrs.color : "0xffffff") + "\n                    " + (tagTree.attrs.intensity ? "," + tagTree.attrs.intensity : "") + "\n                );\n                ";
            tagTree.attrs.shadow ? light += shadow : "";
        }
        light += "\n          " + (tagTree.attrs.position ? "light.position.set(" + tagTree.attrs.position.x + "," + tagTree.attrs.position.y + "," + tagTree.attrs.position.z + ");" : "") + "\n          " + (tagTree.attrs.visible === false ? "light.visible = false;" : "") + "\n          " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = light;" : "") + "\n          scene.add(light);\n          ";
        var funcName = this._getVarName();
        var code = "function " + funcName + "(){\n " + light + "};\n " + funcName + "();\n ";
        return code;
    };
    JSBuilder.prototype._mt = function (tagTree) {
        var type = tagTree.attrs.type ? tagTree.attrs.type : "MeshBasicMaterial";
        tagTree.attrs.map ? this._total++ : "";
        var code = "\n          " + (tagTree.attrs.map ? "const map = new THREE.TextureLoader().load('" + tagTree.attrs.map +
            "',()=>{scene.loading.count++;scene.loading.progress = scene.loading.count/scene.loading.total * 100 + '%';scene.loading.count === scene.loading.total ? scene.ready() :'';});" : "") + "\n          const mt = new THREE." + type + "({\n               color:" + (tagTree.attrs.color ? tagTree.attrs.color : "0xffffff") + "\n               " + (tagTree.attrs.map ? ",map:map" : "") + "\n               " + (tagTree.attrs.transparent ? ",transparent:true" : "") + "\n               " + (tagTree.attrs.opacity ? ",opacity:" + tagTree.attrs.opacity : "") + "\n               " + (tagTree.attrs.side ? ",side:" + tagTree.attrs.side : "") + "\n               })\n\n          " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = mt;" : "") + "\n          ";
        return code;
    };
    JSBuilder.prototype._geo = function (tagTree) {
        var code = "const geo = ";
        if (tagTree.attrs.type === "sphere") {
            //球缓冲几何体
            code += "\n               new THREE.SphereGeometry(\n                    " + (tagTree.attrs.r ? tagTree.attrs.r : 1) + ",\n                    " + (tagTree.attrs.seg ? tagTree.attrs.seg : 32) + ",\n                    " + (tagTree.attrs.seg ? tagTree.attrs.seg : 32) + "\n               );\n\n               ";
        }
        else if (tagTree.attrs.type === "plane") {
            //矩形平面缓冲几何体
            code += "\n               new THREE.PlaneGeometry(\n                    " + (tagTree.attrs.length ? tagTree.attrs.length : "1") + ",\n                    " + (tagTree.attrs.width ? tagTree.attrs.width : "1") + "\n               );\n\n               ";
        }
        else if (tagTree.attrs.type === "circle") {
            //圆缓冲几何体
            code += "\n               new THREE.CircleGeometry(\n                    " + (tagTree.attrs.r ? tagTree.attrs.r : 1) + ",\n                    " + (tagTree.attrs.seg ? tagTree.attrs.seg : 32) + "\n               );\n\n               ";
        }
        else if (tagTree.attrs.type === "cone") {
            //圆锥缓冲几何体
            code += "\n               new THREE.ConeGeometry(\n                    " + (tagTree.attrs.r ? tagTree.attrs.r : 1) + ",\n                    " + (tagTree.attrs.height ? tagTree.attrs.height : 1) + ",\n                    " + (tagTree.attrs.seg ? tagTree.attrs.seg : 32) + "\n               );\n\n               ";
        }
        else if (tagTree.attrs.type === "cylinder") {
            //圆柱缓冲几何体
            code += "\n               new THREE.CylinderGeometry(\n                    " + (tagTree.attrs.rt ? tagTree.attrs.rt : 1) + ",\n                    " + (tagTree.attrs.rb ? tagTree.attrs.rb : 1) + ",\n                    " + (tagTree.attrs.height ? tagTree.attrs.height : 1) + ",\n                    " + (tagTree.attrs.seg ? tagTree.attrs.seg : 32) + "\n               );\n\n               ";
        }
        else {
            //立方缓冲几何体
            code += "\n               new THREE.BoxGeometry(\n                    " + (tagTree.attrs.length ? tagTree.attrs.length : 1) + ",\n                    " + (tagTree.attrs.height ? tagTree.attrs.height : 1) + ",\n                    " + (tagTree.attrs.width ? tagTree.attrs.width : 1) + "\n               );\n\n               ";
        }
        tagTree.attrs.ref ? code = code + " scene.refs." + tagTree.attrs.ref + " = geo;" : "";
        return code;
    };
    JSBuilder.prototype._mesh = function (tagTree, parentKey) {
        var count = 0;
        var mt, geo = "";
        for (var _i = 0, _a = tagTree.children; _i < _a.length; _i++) {
            var tag = _a[_i];
            if (tag.tag === "mt") {
                mt = this._mt(tag);
                count++;
            }
            else if (tag.tag === "geo") {
                geo = this._geo(tag);
                count++;
            }
            if (count === 2) {
                break;
            }
        }
        if (!mt || !geo) {
            return "";
        }
        var code = "\n          " + mt + "\n          " + geo + "\n          const mesh = new THREE.Mesh(geo,mt);\n          " + (tagTree.attrs.position ? "mesh.position.set(" + tagTree.attrs.position.x + "," + tagTree.attrs.position.y + "," + tagTree.attrs.position.z + ");" : "") + "\n          " + (tagTree.attrs.rotation ? "mesh.rotation.set(" + tagTree.attrs.rotation.x + "," + tagTree.attrs.rotation.y + "," + tagTree.attrs.rotation.z + ");" : "") + "\n          " + (tagTree.attrs.scale ? "mesh.scale.set(" + tagTree.attrs.scale.x + "," + tagTree.attrs.scale.y + "," + tagTree.attrs.scale.z + ");" : "") + "\n          " + (tagTree.attrs.visible === false ? "mesh.visible = false;" : "") + "\n          " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = mesh;" : "") + "\n          ";
        if (tagTree.attrs.shadow) {
            code += "\n               mesh.castShadow = true;\n               mesh.receiveShadow = true;\n               ";
        }
        if (parentKey) {
            code += parentKey + ".add(mesh);\n";
        }
        else {
            code += "scene.add(mesh);\n";
        }
        var funcName = this._getVarName();
        code = "function " + funcName + "(){" + code + "};\n " + funcName + "();\n";
        return code;
    };
    JSBuilder.prototype._sprite = function (tagTree) {
        var mt = "";
        for (var _i = 0, _a = tagTree.children; _i < _a.length; _i++) {
            var tag = _a[_i];
            if (tag.tag === "mt") {
                tag.attrs.type = "SpriteMaterial";
                mt = this._mt(tag);
                break;
            }
        }
        if (!mt) {
            return "";
        }
        var code = "\n          " + mt + "\n          const sprite = new THREE.Sprite(mt);\n          " + (tagTree.attrs.position ? "sprite.position.set(" + tagTree.attrs.position.x + "," + tagTree.attrs.position.y + "," + tagTree.attrs.position.z + ");" : "") + "\n          " + (tagTree.attrs.rotation ? "sprite.rotation.set(" + tagTree.attrs.rotation.x + "," + tagTree.attrs.rotation.y + "," + tagTree.attrs.rotation.z + ");" : "") + "\n          " + (tagTree.attrs.scale ? "sprite.scale.set(" + tagTree.attrs.scale.x + "," + tagTree.attrs.scale.y + "," + tagTree.attrs.scale.z + ");" : "") + "\n          " + (tagTree.attrs.visible === false ? "sprite.visible = false;" : "") + "\n          " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = sprite;" : "") + "\n          scene.add(sprite);\n          ";
        var funcName = this._getVarName();
        code = "function " + funcName + "(){" + code + "};\n " + funcName + "();\n ";
        return code;
    };
    JSBuilder.prototype._group = function (tagTree, parentKey) {
        var _this = this;
        var groupName = this._getVarName();
        var code = "\n          const " + groupName + " = new THREE.Group();\n          ";
        var childCode = "";
        tagTree.children.forEach(function (tag) {
            if (tag.tag === "mesh") {
                childCode += _this._mesh(tag, groupName);
            }
            else {
                childCode += _this._group(tag, groupName);
            }
        });
        code += childCode;
        code += "\n          " + (tagTree.attrs.position ? groupName + ".position.set(" + tagTree.attrs.position.x + "," + tagTree.attrs.position.y + "," + tagTree.attrs.position.z + ");" : "") + "\n          " + (tagTree.attrs.rotation ? groupName + ".rotation.set(" + tagTree.attrs.rotation.x + "," + tagTree.attrs.rotation.y + "," + tagTree.attrs.rotation.z + ");" : "") + "\n          " + (tagTree.attrs.scale ? groupName + ".scale.set(" + tagTree.attrs.scale.x + "," + tagTree.attrs.scale.y + "," + tagTree.attrs.scale.z + ");" : "") + "\n          " + (tagTree.attrs.visible === false ? groupName + ".visible = false;" : "") + "\n          " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = " + groupName + ";" : "") + "\n          ";
        if (parentKey) {
            code += parentKey + ".add(" + groupName + ");\n ";
        }
        else {
            code += "scene.add(" + groupName + ");";
            var funcName = this._getVarName();
            code = "function " + funcName + "(){" + code + "};\n " + funcName + "();\n ";
        }
        return code;
    };
    JSBuilder.prototype._ui = function (tagTree, parent) {
        var _this = this;
        var domName = this._getVarName();
        var text = "";
        if (tagTree.attrs.text) {
            text = "document.createTextNode('" + tagTree.attrs.text + "')";
        }
        var code = "\n          const " + domName + " = document.createElement(\"div\");\n          " + (tagTree.attrs.class ? domName + ".classList.add('" + tagTree.attrs.class + "');" : "") + "\n          " + (tagTree.attrs.style ? domName + ".setAttribute('style','" + tagTree.attrs.style + "');" : "") + "\n          " + (tagTree.attrs.visible === false ? domName + ".style.display = 'none';" : "") + "\n          " + (tagTree.attrs.click ? domName + ".addEventListener('click'," + tagTree.attrs.click + ");" : "") + "\n          " + (text ? domName + ".appendChild(" + text + ");" : "") + "\n          " + (tagTree.attrs.ref ? "scene.refs." + tagTree.attrs.ref + " = " + domName + ";" : "") + "\n          ";
        tagTree.children.forEach(function (tag) {
            code += _this._ui(tag, domName);
        });
        if (parent) {
            code += parent + ".appendChild(" + domName + ");\n ";
        }
        else {
            code += "scene.container.appendChild(" + domName + ");\n ";
            var funcName = this._getVarName();
            code = "function " + funcName + "(){" + code + "}\n " + funcName + "();\n ";
        }
        return code;
    };
    return JSBuilder;
}());
exports.JSBuilder = JSBuilder;
